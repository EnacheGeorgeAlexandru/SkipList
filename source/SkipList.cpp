#include "SkipList.h"

int SkipList::generateRandomLevel() {
    // Will be used to obtain a seed for the random number engine
    std::random_device rd;
    // Standard linear_congruential_engine seeded with rd()
    std::minstd_rand gen(rd());
    //Generates a random real number in range [0,1) with 10 bits of randomness using random unsigned int
    // generated by gen
    double real = std::generate_canonical<double, 10>(gen);
    int randomLevel = 0;
    while (real < probability and randomLevel < MAX_LEVEL) {
        randomLevel++;
        real = std::generate_canonical<double, 10>(gen);
    }
    return randomLevel;
}

SkipList::SkipList(double probability_, int headValue) {
    level = 0;
    probability = probability_;
    head = new Node(headValue, MAX_LEVEL);
}
void SkipList::insert(int value) {
    std::vector<Node*> update;
    Node* current = head;
    for (int i = level; i >= 0; i--) {
        while (current->next[i] and current->next[i]->value < value) {
            current = current->next[i];
        }
        update.insert(update.begin(), current);
    }
    if (current->next[0] && current->next[0]->value == value)
        return;
    int randomLevel = generateRandomLevel();
    if (randomLevel > level) {
        while (level < randomLevel) {
            update.push_back(head);
            level++;
        }
    }
    Node* node = new Node(value, randomLevel);
    for (int i = 0; i <= randomLevel; i++) {
        node->next[i] = update[i]->next[i];
        update[i]->next[i] = node;
    }
}
bool SkipList::search(int value) {
    Node* current = head;
    for (int i = level; i >= 0; i--) {
        while (current->next[i] and current->next[i]->value < value) {
            current = current->next[i];
        }
    }
    if (current->next[0] and current->next[0]->value == value) {
        std::cout << "Found value: " << value << "\n";
        return true;
    }
    std::cout << "Did not found value: " << value << "\n";
    return false;
}
bool SkipList::erase(int value) {
    std::vector<Node*> update;
    Node* current = head;
    for (int i = level; i >= 0; i--) {
        while (current->next[i] and current->next[i]->value < value) {
            current = current->next[i];
        }
        update.insert(update.begin(), current);
    }
    Node* nodeToErase = current->next[0];
    if (current->next[0] == nullptr or current->next[0]->value != value) {
        std::cout << "The value to be deleted is not in the list.\n";
        return false;
    }
    for (int i = 0; i <= level; i++) {
        if (update[i]->next[i] != nodeToErase)
            break;
        update[i]->next[i] = nodeToErase->next[i];
    }
    while (level > 0 and head->next[level] == nullptr)
        level--;
    delete nodeToErase;
    std::cout << "Deleted value: " << value << "\n";
    return true;
}
void SkipList::print() {
    for (int i = 0; i <= level; i++) {
        std::cout << "Level " << i << ": ";
        Node* current = head->next[i];
        while (current) {
            std::cout << current->value << " ";
            current = current->next[i];
        }
        std::cout << "\n";
    }
}